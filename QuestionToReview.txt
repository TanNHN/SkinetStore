1. builder.Services.AddScoped<ProductRepository>() vs builder.Services.AddScoped<IProductRepository, ProductRepository>();
2. ToList vs ToListAsync, SaveChangesAsync() or SaveChanges(),... : https://stackoverflow.com/questions/30042791/entity-framework-savechanges-vs-savechangesasync-and-find-vs-findasync
3. IEnumerable vs IQueryable: https://stackoverflow.com/a/23359554
4. Public class with static method? Why not static class with static method
5. Products.Where(x => 
        (string.IsNullOrEmpty(brand) || x.Brand == brand) &&
        (string.IsNullOrEmpty(type) || x.Type == type))
6.ProductsController line 20, how type T is automatically recognize as Product without set <Product> to <T>
7. SelectMany
8. Products.Select(x => ["Iphone", "Xiaomi"].Contains(x.Type)) does this work as product filter conditions?
9. RSjx?
10. why multple interceptor
11. diff between required declared in property and [Required]
12. When dotnet ef migrartions, it create new migrations file, that file contain only the new entity your created,
  why it only contain that creation of that new entity not all the entity off the app
13. Why has separate of the same Address class (Address entity and AddessDTO) 
14. { withCredentials: true }
15. cookies with HttpOnly flag can't be access to by js, so how do we check if a user is logged in
16. lastValueFrom()
17. Khi nào nên dùng add Scope, cho vd
18. export interface vs export class 
19. 
await firstValueFrom(this.stripeService.createOrUpdatePaymentIntent());
vs
await this.stripeService.createOrUpdatePaymentIntent();
are they the same?

20. public ShippingAddress ShippingAddress { get; set; } = null!;
21. builder.Property(x => x.Status).HasConversion(
    o => o.ToString(),
    o => (OrderStatus) Enum.Parse(typeof(OrderStatus), o)
);

22. Conventions concept in create migration inside ef core
Note:

23. Without any attributes or Fluent API, what relationship will 
EF Core set up between User and Order (1–1, 1–many, many–many), 
and which is the principal and which is the dependent?

24. Shadow key

25. ActionResult vs IActionResult 
26. public static OrderItemDTO ToDTO(this OrderItem orderItem) extension method
27.
public async Task<ActionResult<IEnumerable<OrderDTO>>> GetOrdersByUserId()
    {
        OrderSpecification spec = new(User.GetEmail());
        IReadOnlyList<Order> orders = await unitOfWork.Repository<Order>().ListAsync(spec);
        IEnumerable<OrderDTO> orderToReturn = orders.Select(o => o.ToDTO());
        return orderToReturn;
    }
Why cant implicit cast Ok(orderToReturn)? type of orderToReturn already match with T in ActionResult<T>

28. Why devide into 3 prjs API, Core, Infrastrucure
BE:
_ Cross-origin resource sharing, which is a security feature 
implemented by web browsers to control how resources on a web page can be requested

_ So different ports means different origin.
And if we want our clients application to be able to request resources from our API server, then we
have to allow that and pass the Cors support back as a Cors header to the browser.

_ app.UseCors(x => x.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200", "https://localhost:4200"));
as they come from this origin, then our web browser will allow us to request this data from
our API and display it on the page.
If we don't have this, the request can still go to our API server, but it's a browser security feature
that will prevent us from actually loading the data into our browser. (but what is the point if the request can go to our API without blocking?)

_ ASP Identity use cookies in the request (Cookie: .AspNetCore.Identity.Application=CfDJ8BU-f5dyeyp...) to auth,
and the http flag inside Cookie prevent js, to access to our cookies. It stay on brower and come with every request
inside header. And we cant remove cookies from angular app so we can did it in BE side => need logout api 

_ with dependency injection, if we're injecting something into something that's
a service, then it has to be the same scope as the thing we're injecting.

_ dùng AddScope cho tác vụ như connect với db, 1 request sẽ chỉ tạo 1 connection tới db, tồn tại trong suốt
vòng đời của request đó, nên ta sẽ ko muốn tạo quá nhiều connection mà chỉ cần 1 và tất cả tác vụ sẽ dùng lại connection đó,
nếu đăng ký = singleton => xác suất lỗi cao do sẽ dc dùng chung bởi nhiều đồng thời reqeust, thread khác nhau 

_ Docker: https://youtu.be/3c-iBn73dDE

FE:
We're operating in standalone mode, then any components that are used inside another component have to be declared in the imports here.
example: 

@Component({
  selector: 'app-root',
  imports: [RouterOutlet, HeaderComponent],
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss'
})

2.
 @Injectable({
  providedIn: 'root',
})
providedIn: 'root': when our application starts up, it's provided automatically for our entire application.
Injectable: we can inject wherever we need in prj

3. [(ngModel)]
Square brackets typically represent input properties, and parentheses typically represent output properties or events

4. Dipose service after use. (Stripe service keep value of previous user logged out) 

TODO:

1. Currently call api user-info after user logged in => return user data when logged in, remove addition api called for user-info