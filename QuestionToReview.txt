1. builder.Services.AddScoped<ProductRepository>() vs builder.Services.AddScoped<IProductRepository, ProductRepository>();
2. ToList vs ToListAsync, SaveChangesAsync() or SaveChanges(),... : https://stackoverflow.com/questions/30042791/entity-framework-savechanges-vs-savechangesasync-and-find-vs-findasync
3. IEnumerable vs IQueryable: https://stackoverflow.com/a/23359554
4. Public class with static method? Why not static class with static method
5. Products.Where(x => 
        (string.IsNullOrEmpty(brand) || x.Brand == brand) &&
        (string.IsNullOrEmpty(type) || x.Type == type))
6.ProductsController line 20, how type T is automatically recognize as Product without set <Product> to <T>
7. SelectMany
8. Products.Select(x => ["Iphone", "Xiaomi"].Contains(x.Type)) does this work as product filter conditions?
9. RSjx?
10. why multple interceptor
11. diff between required declared in property and [Required]
12. When dotnet ef migrartions, it create new migrations file, that file contain only the new entity your created,
  why it only contain that creation of that new entity not all the entity off the app
13. Why has separate of the same Address class (Address entity and AddessDTO) 
14. { withCredentials: true }
15. cookies with HttpOnly flag can't be access to by js, so how do we check if a user is logged in
16. lastValueFrom()
17. Khi nào nên dùng add Scope, cho vd
18. export interface vs export class 
19. 
await firstValueFrom(this.stripeService.createOrUpdatePaymentIntent());
vs
await this.stripeService.createOrUpdatePaymentIntent();
are they the same?

20.
Note:

BE:
_ Cross-origin resource sharing, which is a security feature 
implemented by web browsers to control how resources on a web page can be requested

_ So different ports means different origin.
And if we want our clients application to be able to request resources from our API server, then we
have to allow that and pass the Cors support back as a Cors header to the browser.

_ app.UseCors(x => x.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:4200", "https://localhost:4200"));
as they come from this origin, then our web browser will allow us to request this data from
our API and display it on the page.
If we don't have this, the request can still go to our API server, but it's a browser security feature
that will prevent us from actually loading the data into our browser. (but what is the point if the request can go to our API without blocking?)

_ ASP Identity use cookies in the request (Cookie: .AspNetCore.Identity.Application=CfDJ8BU-f5dyeyp...) to auth,
and the http flag inside Cookie prevent js, to access to our cookies. It stay on brower and come with every request
inside header. And we cant remove cookies from angular app so we can did it in BE side => need logout api 


FE:
We're operating in standalone mode, then any components that are used inside another component have to be declared in the imports here.
example: 

@Component({
  selector: 'app-root',
  imports: [RouterOutlet, HeaderComponent],
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss'
})

2.
 @Injectable({
  providedIn: 'root',
})
providedIn: 'root': when our application starts up, it's provided automatically for our entire application.
Injectable: we can inject wherever we need in prj

3. [(ngModel)]
Square brackets typically represent input properties, and parentheses typically represent output properties or events

4. Dipose service after use. (Stripe service keep value of previous user logged out) 

TODO:

1. Currently call api user-info after user logged in => return user data when logged in, remove addition api called for user-info